# coding: utf-8

"""
    Gitea API.

    This documentation describes the Gitea API.  # noqa: E501

    The version of the OpenAPI document: 1.18.0+1
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rcmt.source.gitea.client.api_client import ApiClient
from rcmt.source.gitea.client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class RepositoryApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accept_repo_transfer(self, owner, repo, **kwargs):  # noqa: E501
        """Accept a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.accept_repo_transfer(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.accept_repo_transfer_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def accept_repo_transfer_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Accept a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.accept_repo_transfer_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_repo_transfer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `accept_repo_transfer`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `accept_repo_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            202: "Repository",
            403: None,
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer/accept', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_current_user_repo(self, **kwargs):  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_current_user_repo(async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.create_current_user_repo_with_http_info(**kwargs)  # noqa: E501

    def create_current_user_repo_with_http_info(self, **kwargs):  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_current_user_repo_with_http_info(async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_current_user_repo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Repository",
            409: None,
            422: None,
        }

        return self.api_client.call_api(
            '/user/repos', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_fork(self, owner, repo, **kwargs):  # noqa: E501
        """Fork a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_fork(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to fork (required)
        :type owner: str
        :param repo: name of the repo to fork (required)
        :type repo: str
        :param body:
        :type body: CreateForkOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.create_fork_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def create_fork_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Fork a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_fork_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to fork (required)
        :type owner: str
        :param repo: name of the repo to fork (required)
        :type repo: str
        :param body:
        :type body: CreateForkOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fork" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `create_fork`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `create_fork`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            202: "Repository",
            403: None,
            409: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/forks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def generate_repo(self, template_owner, template_repo, **kwargs):  # noqa: E501
        """Create a repository using a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.generate_repo(template_owner, template_repo, async_req=True)
        >>> result = thread.get()

        :param template_owner: name of the template repository owner (required)
        :type template_owner: str
        :param template_repo: name of the template repository (required)
        :type template_repo: str
        :param body:
        :type body: GenerateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.generate_repo_with_http_info(template_owner, template_repo, **kwargs)  # noqa: E501

    def generate_repo_with_http_info(self, template_owner, template_repo, **kwargs):  # noqa: E501
        """Create a repository using a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.generate_repo_with_http_info(template_owner, template_repo, async_req=True)
        >>> result = thread.get()

        :param template_owner: name of the template repository owner (required)
        :type template_owner: str
        :param template_repo: name of the template repository (required)
        :type template_repo: str
        :param body:
        :type body: GenerateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'template_owner',
            'template_repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_repo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_owner' is set
        if self.api_client.client_side_validation and local_var_params.get('template_owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_owner` when calling `generate_repo`")  # noqa: E501
        # verify the required parameter 'template_repo' is set
        if self.api_client.client_side_validation and local_var_params.get('template_repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_repo` when calling `generate_repo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_owner' in local_var_params:
            path_params['template_owner'] = local_var_params['template_owner']  # noqa: E501
        if 'template_repo' in local_var_params:
            path_params['template_repo'] = local_var_params['template_repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Repository",
            403: None,
            404: None,
            409: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{template_owner}/{template_repo}/generate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_annotated_tag(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the tag object of an annotated tag (not lightweight tags)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotated_tag(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AnnotatedTag
        """
        kwargs['_return_http_data_only'] = True
        return self.get_annotated_tag_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def get_annotated_tag_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the tag object of an annotated tag (not lightweight tags)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotated_tag_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AnnotatedTag, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotated_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `get_annotated_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `get_annotated_tag`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `get_annotated_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "AnnotatedTag",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/tags/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_blob(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the blob of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_blob(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_blob_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def get_blob_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the blob of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_blob_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blob" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `get_blob`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `get_blob`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `get_blob`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "GitBlobResponse",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/blobs/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_tree(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the tree of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tree(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param recursive: show all directories and files
        :type recursive: bool
        :param page: page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
        :type page: int
        :param per_page: number of items per page
        :type per_page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitTreeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tree_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def get_tree_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Gets the tree of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tree_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param recursive: show all directories and files
        :type recursive: bool
        :param page: page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
        :type page: int
        :param per_page: number of items per page
        :type per_page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitTreeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha',
            'recursive',
            'page',
            'per_page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `get_tree`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `get_tree`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `get_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []
        if local_var_params.get('recursive') is not None:  # noqa: E501
            query_params.append(('recursive', local_var_params['recursive']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('per_page') is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "GitTreeResponse",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/trees/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def list_forks(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's forks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_forks(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Repository]
        """
        kwargs['_return_http_data_only'] = True
        return self.list_forks_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def list_forks_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's forks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_forks_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Repository], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_forks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `list_forks`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `list_forks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Repository]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/forks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def reject_repo_transfer(self, owner, repo, **kwargs):  # noqa: E501
        """Reject a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reject_repo_transfer(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.reject_repo_transfer_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def reject_repo_transfer_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Reject a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reject_repo_transfer_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_repo_transfer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `reject_repo_transfer`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `reject_repo_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Repository",
            403: None,
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer/reject', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_add_collaborator(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Add a collaborator to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_collaborator(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to add (required)
        :type collaborator: str
        :param body:
        :type body: AddCollaboratorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_add_collaborator_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    def repo_add_collaborator_with_http_info(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Add a collaborator to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_collaborator_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to add (required)
        :type collaborator: str
        :param body:
        :type body: AddCollaboratorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'collaborator',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_collaborator" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_add_collaborator`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_add_collaborator`")  # noqa: E501
        # verify the required parameter 'collaborator' is set
        if self.api_client.client_side_validation and local_var_params.get('collaborator') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `collaborator` when calling `repo_add_collaborator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'collaborator' in local_var_params:
            path_params['collaborator'] = local_var_params['collaborator']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'PUT', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_add_push_mirror(self, owner, repo, **kwargs):  # noqa: E501
        """add a push mirror to the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_push_mirror(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePushMirrorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PushMirror
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_add_push_mirror_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_add_push_mirror_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """add a push mirror to the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_push_mirror_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePushMirrorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PushMirror, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_push_mirror" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_add_push_mirror`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_add_push_mirror`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "PushMirror",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_add_team(self, owner, repo, team, **kwargs):  # noqa: E501
        """Add a team to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_add_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    def repo_add_team_with_http_info(self, owner, repo, team, **kwargs):  # noqa: E501
        """Add a team to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'team'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_team" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_add_team`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_add_team`")  # noqa: E501
        # verify the required parameter 'team' is set
        if self.api_client.client_side_validation and local_var_params.get('team') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `team` when calling `repo_add_team`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'team' in local_var_params:
            path_params['team'] = local_var_params['team']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_add_topic(self, owner, repo, topic, **kwargs):  # noqa: E501
        """Add a topic to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_topic(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to add (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_add_topic_with_http_info(owner, repo, topic, **kwargs)  # noqa: E501

    def repo_add_topic_with_http_info(self, owner, repo, topic, **kwargs):  # noqa: E501
        """Add a topic to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_topic_with_http_info(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to add (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'topic'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_topic" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_add_topic`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_add_topic`")  # noqa: E501
        # verify the required parameter 'topic' is set
        if self.api_client.client_side_validation and local_var_params.get('topic') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic` when calling `repo_add_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'topic' in local_var_params:
            path_params['topic'] = local_var_params['topic']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics/{topic}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_apply_diff_patch(self, owner, repo, body, **kwargs):  # noqa: E501
        """Apply diff patch to repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_apply_diff_patch(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_apply_diff_patch_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    def repo_apply_diff_patch_with_http_info(self, owner, repo, body, **kwargs):  # noqa: E501
        """Apply diff patch to repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_apply_diff_patch_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_apply_diff_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_apply_diff_patch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_apply_diff_patch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_apply_diff_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "FileResponse",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/diffpatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_cancel_scheduled_auto_merge(self, owner, repo, index, **kwargs):  # noqa: E501
        """Cancel the scheduled auto merge for the given pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_cancel_scheduled_auto_merge(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_cancel_scheduled_auto_merge_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_cancel_scheduled_auto_merge_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Cancel the scheduled auto merge for the given pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_cancel_scheduled_auto_merge_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_cancel_scheduled_auto_merge" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_cancel_scheduled_auto_merge`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_cancel_scheduled_auto_merge`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_cancel_scheduled_auto_merge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_check_collaborator(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Check if a user is a collaborator of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_collaborator(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_check_collaborator_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    def repo_check_collaborator_with_http_info(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Check if a user is a collaborator of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_collaborator_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_check_collaborator" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_check_collaborator`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_check_collaborator`")  # noqa: E501
        # verify the required parameter 'collaborator' is set
        if self.api_client.client_side_validation and local_var_params.get('collaborator') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `collaborator` when calling `repo_check_collaborator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'collaborator' in local_var_params:
            path_params['collaborator'] = local_var_params['collaborator']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_check_team(self, owner, repo, team, **kwargs):  # noqa: E501
        """Check if a team is assigned to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Team
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_check_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    def repo_check_team_with_http_info(self, owner, repo, team, **kwargs):  # noqa: E501
        """Check if a team is assigned to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Team, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'team'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_check_team" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_check_team`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_check_team`")  # noqa: E501
        # verify the required parameter 'team' is set
        if self.api_client.client_side_validation and local_var_params.get('team') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `team` when calling `repo_check_team`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'team' in local_var_params:
            path_params['team'] = local_var_params['team']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Team",
            404: None,
            405: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_branch(self, owner, repo, **kwargs):  # noqa: E501
        """Create a branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_branch_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_branch_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_branch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_branch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Branch",
            404: None,
            409: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_branch_protection(self, owner, repo, **kwargs):  # noqa: E501
        """Create a branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_protection(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_branch_protection_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_branch_protection_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_protection_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_branch_protection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_branch_protection`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_branch_protection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "BranchProtection",
            403: None,
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_file(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Create a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to create (required)
        :type filepath: str
        :param body: (required)
        :type body: CreateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    def repo_create_file_with_http_info(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Create a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to create (required)
        :type filepath: str
        :param body: (required)
        :type body: CreateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_file`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_file`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_create_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_create_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "FileResponse",
            403: None,
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_hook(self, owner, repo, **kwargs):  # noqa: E501
        """Create a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_hook(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_hook_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_hook_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_hook_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Hook",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_key(self, owner, repo, **kwargs):  # noqa: E501
        """Add a key to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_key(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeployKey
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_key_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_key_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Add a key to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_key_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeployKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_key`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "DeployKey",
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_pull_request(self, owner, repo, **kwargs):  # noqa: E501
        """Create a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_request(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_pull_request_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_pull_request_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_request_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_pull_request`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_pull_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "PullRequest",
            409: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_pull_review(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """Create a review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: CreatePullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_pull_review_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    def repo_create_pull_review_with_http_info(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """Create a review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: CreatePullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_create_pull_review`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_create_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullReview",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_pull_review_requests(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """create review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_requests(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[PullReview]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_pull_review_requests_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    def repo_create_pull_review_requests_with_http_info(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """create review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_requests_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[PullReview], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_review_requests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_create_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_create_pull_review_requests`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "list[PullReview]",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_release(self, owner, repo, **kwargs):  # noqa: E501
        """Create a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_release_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_release_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_release" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_release`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_release`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Release",
            404: None,
            409: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_release_attachment(self, owner, repo, id, attachment, **kwargs):  # noqa: E501
        """Create a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_attachment(owner, repo, id, attachment, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment: attachment to upload (required)
        :type attachment: file
        :param name: name of the attachment
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_release_attachment_with_http_info(owner, repo, id, attachment, **kwargs)  # noqa: E501

    def repo_create_release_attachment_with_http_info(self, owner, repo, id, attachment, **kwargs):  # noqa: E501
        """Create a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_attachment_with_http_info(owner, repo, id, attachment, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment: attachment to upload (required)
        :type attachment: file
        :param name: name of the attachment
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'attachment',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_release_attachment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_release_attachment`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_release_attachment`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_create_release_attachment`")  # noqa: E501
        # verify the required parameter 'attachment' is set
        if self.api_client.client_side_validation and local_var_params.get('attachment') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `attachment` when calling `repo_create_release_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if local_var_params.get('name') is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}
        if 'attachment' in local_var_params:
            local_var_files['attachment'] = local_var_params['attachment']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Attachment",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_status(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Create a commit status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_status(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param body:
        :type body: CreateStatusOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CommitStatus
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_status_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def repo_create_status_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Create a commit status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_status_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param body:
        :type body: CreateStatusOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CommitStatus, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_status`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_status`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `repo_create_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "CommitStatus",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/statuses/{sha}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_tag(self, owner, repo, **kwargs):  # noqa: E501
        """Create a new git tag in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_tag(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateTagOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Tag
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_tag_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_tag_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a new git tag in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_tag_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateTagOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Tag, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Tag",
            404: None,
            405: None,
            409: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_create_wiki_page(self, owner, repo, **kwargs):  # noqa: E501
        """Create a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_wiki_page(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_create_wiki_page_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_create_wiki_page_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Create a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_wiki_page_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_wiki_page" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_create_wiki_page`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_create_wiki_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "WikiPage",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/new', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete(self, owner, repo, **kwargs):  # noqa: E501
        """Delete a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to delete (required)
        :type owner: str
        :param repo: name of the repo to delete (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_delete_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Delete a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to delete (required)
        :type owner: str
        :param repo: name of the repo to delete (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_branch(self, owner, repo, branch, **kwargs):  # noqa: E501
        """Delete a specific branch from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to delete (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_branch_with_http_info(owner, repo, branch, **kwargs)  # noqa: E501

    def repo_delete_branch_with_http_info(self, owner, repo, branch, **kwargs):  # noqa: E501
        """Delete a specific branch from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_with_http_info(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to delete (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'branch'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_branch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_branch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_branch`")  # noqa: E501
        # verify the required parameter 'branch' is set
        if self.api_client.client_side_validation and local_var_params.get('branch') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `branch` when calling `repo_delete_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'branch' in local_var_params:
            path_params['branch'] = local_var_params['branch']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches/{branch}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_branch_protection(self, owner, repo, name, **kwargs):  # noqa: E501
        """Delete a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_protection(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_branch_protection_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    def repo_delete_branch_protection_with_http_info(self, owner, repo, name, **kwargs):  # noqa: E501
        """Delete a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_protection_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_branch_protection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_branch_protection`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_branch_protection`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and local_var_params.get('name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `repo_delete_branch_protection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_collaborator(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Delete a collaborator from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_collaborator(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to delete (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_collaborator_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    def repo_delete_collaborator_with_http_info(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Delete a collaborator from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_collaborator_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to delete (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_collaborator" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_collaborator`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_collaborator`")  # noqa: E501
        # verify the required parameter 'collaborator' is set
        if self.api_client.client_side_validation and local_var_params.get('collaborator') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `collaborator` when calling `repo_delete_collaborator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'collaborator' in local_var_params:
            path_params['collaborator'] = local_var_params['collaborator']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_file(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Delete a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to delete (required)
        :type filepath: str
        :param body: (required)
        :type body: DeleteFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    def repo_delete_file_with_http_info(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Delete a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to delete (required)
        :type filepath: str
        :param body: (required)
        :type body: DeleteFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_file`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_file`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_delete_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'DELETE', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "FileDeleteResponse",
            400: None,
            403: None,
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_git_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_git_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_git_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_delete_git_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_git_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_git_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_git_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_git_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_git_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_delete_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_key(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a key from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_key(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_key_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_delete_key_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a key from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_key_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_key`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_key`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_pull_review(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Delete a specific review from a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    def repo_delete_pull_review_with_http_info(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Delete a specific review from a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_delete_pull_review`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_pull_review_requests(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """cancel review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_requests(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_pull_review_requests_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    def repo_delete_pull_review_requests_with_http_info(self, owner, repo, index, body, **kwargs):  # noqa: E501
        """cancel review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_requests_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_pull_review_requests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_delete_pull_review_requests`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_delete_pull_review_requests`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'DELETE', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_push_mirror(self, owner, repo, name, **kwargs):  # noqa: E501
        """deletes a push mirror from a repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_push_mirror(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of the pushMirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_push_mirror_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    def repo_delete_push_mirror_with_http_info(self, owner, repo, name, **kwargs):  # noqa: E501
        """deletes a push mirror from a repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_push_mirror_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of the pushMirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_push_mirror" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_push_mirror`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_push_mirror`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and local_var_params.get('name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `repo_delete_push_mirror`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_release(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_release_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_delete_release_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Delete a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_release`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_release`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_release`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_release_attachment(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Delete a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_attachment(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to delete (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_release_attachment_with_http_info(owner, repo, id, attachment_id, **kwargs)  # noqa: E501

    def repo_delete_release_attachment_with_http_info(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Delete a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_attachment_with_http_info(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to delete (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release_attachment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_release_attachment`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_release_attachment`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_delete_release_attachment`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('attachment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `repo_delete_release_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['attachment_id'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_release_by_tag(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Delete a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_by_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_release_by_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    def repo_delete_release_by_tag_with_http_info(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Delete a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_by_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'tag'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release_by_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_release_by_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_release_by_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and local_var_params.get('tag') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag` when calling `repo_delete_release_by_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'tag' in local_var_params:
            path_params['tag'] = local_var_params['tag']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/tags/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_tag(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Delete a repository's tag by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    def repo_delete_tag_with_http_info(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Delete a repository's tag by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'tag'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and local_var_params.get('tag') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag` when calling `repo_delete_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'tag' in local_var_params:
            path_params['tag'] = local_var_params['tag']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_team(self, owner, repo, team, **kwargs):  # noqa: E501
        """Delete a team from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    def repo_delete_team_with_http_info(self, owner, repo, team, **kwargs):  # noqa: E501
        """Delete a team from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'team'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_team" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_team`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_team`")  # noqa: E501
        # verify the required parameter 'team' is set
        if self.api_client.client_side_validation and local_var_params.get('team') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `team` when calling `repo_delete_team`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'team' in local_var_params:
            path_params['team'] = local_var_params['team']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_topic(self, owner, repo, topic, **kwargs):  # noqa: E501
        """Delete a topic from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_topic(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to delete (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_topic_with_http_info(owner, repo, topic, **kwargs)  # noqa: E501

    def repo_delete_topic_with_http_info(self, owner, repo, topic, **kwargs):  # noqa: E501
        """Delete a topic from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_topic_with_http_info(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to delete (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'topic'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_topic" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_topic`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_topic`")  # noqa: E501
        # verify the required parameter 'topic' is set
        if self.api_client.client_side_validation and local_var_params.get('topic') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic` when calling `repo_delete_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'topic' in local_var_params:
            path_params['topic'] = local_var_params['topic']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics/{topic}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_delete_wiki_page(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Delete a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_wiki_page(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_delete_wiki_page_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    def repo_delete_wiki_page_with_http_info(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Delete a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_wiki_page_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_wiki_page" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_delete_wiki_page`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_delete_wiki_page`")  # noqa: E501
        # verify the required parameter 'page_name' is set
        if self.api_client.client_side_validation and local_var_params.get('page_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_name` when calling `repo_delete_wiki_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'page_name' in local_var_params:
            path_params['pageName'] = local_var_params['page_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_dismiss_pull_review(self, owner, repo, index, id, body, **kwargs):  # noqa: E501
        """Dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_dismiss_pull_review(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: DismissPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_dismiss_pull_review_with_http_info(owner, repo, index, id, body, **kwargs)  # noqa: E501

    def repo_dismiss_pull_review_with_http_info(self, owner, repo, index, id, body, **kwargs):  # noqa: E501
        """Dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_dismiss_pull_review_with_http_info(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: DismissPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_dismiss_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_dismiss_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullReview",
            403: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_download_commit_diff_or_patch(self, owner, repo, sha, diff_type, **kwargs):  # noqa: E501
        """Get a commit's diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_commit_diff_or_patch(owner, repo, sha, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA of the commit to get (required)
        :type sha: str
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_download_commit_diff_or_patch_with_http_info(owner, repo, sha, diff_type, **kwargs)  # noqa: E501

    def repo_download_commit_diff_or_patch_with_http_info(self, owner, repo, sha, diff_type, **kwargs):  # noqa: E501
        """Get a commit's diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_commit_diff_or_patch_with_http_info(owner, repo, sha, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA of the commit to get (required)
        :type sha: str
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha',
            'diff_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_download_commit_diff_or_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_download_commit_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_download_commit_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `repo_download_commit_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'diff_type' is set
        if self.api_client.client_side_validation and local_var_params.get('diff_type') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `diff_type` when calling `repo_download_commit_diff_or_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501
        if 'diff_type' in local_var_params:
            path_params['diffType'] = local_var_params['diff_type']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "str",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/commits/{sha}.{diffType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_download_pull_diff_or_patch(self, owner, repo, index, diff_type, **kwargs):  # noqa: E501
        """Get a pull request diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_pull_diff_or_patch(owner, repo, index, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param binary: whether to include binary file changes. if true, the diff is applicable with `git apply`
        :type binary: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_download_pull_diff_or_patch_with_http_info(owner, repo, index, diff_type, **kwargs)  # noqa: E501

    def repo_download_pull_diff_or_patch_with_http_info(self, owner, repo, index, diff_type, **kwargs):  # noqa: E501
        """Get a pull request diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_pull_diff_or_patch_with_http_info(owner, repo, index, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param binary: whether to include binary file changes. if true, the diff is applicable with `git apply`
        :type binary: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'diff_type',
            'binary'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_download_pull_diff_or_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_download_pull_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_download_pull_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_download_pull_diff_or_patch`")  # noqa: E501
        # verify the required parameter 'diff_type' is set
        if self.api_client.client_side_validation and local_var_params.get('diff_type') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `diff_type` when calling `repo_download_pull_diff_or_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'diff_type' in local_var_params:
            path_params['diffType'] = local_var_params['diff_type']  # noqa: E501

        query_params = []
        if local_var_params.get('binary') is not None:  # noqa: E501
            query_params.append(('binary', local_var_params['binary']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "str",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}.{diffType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit(self, owner, repo, **kwargs):  # noqa: E501
        """Edit a repository's properties. Only fields that are set will be changed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to edit (required)
        :type owner: str
        :param repo: name of the repo to edit (required)
        :type repo: str
        :param body: Properties of a repo that you can edit
        :type body: EditRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_edit_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Edit a repository's properties. Only fields that are set will be changed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to edit (required)
        :type owner: str
        :param repo: name of the repo to edit (required)
        :type repo: str
        :param body: Properties of a repo that you can edit
        :type body: EditRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Repository",
            403: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_branch_protection(self, owner, repo, name, **kwargs):  # noqa: E501
        """Edit a branch protections for a repository. Only fields that are set will be changed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_branch_protection(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param body:
        :type body: EditBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_branch_protection_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    def repo_edit_branch_protection_with_http_info(self, owner, repo, name, **kwargs):  # noqa: E501
        """Edit a branch protections for a repository. Only fields that are set will be changed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_branch_protection_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param body:
        :type body: EditBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'name',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_branch_protection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_branch_protection`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_branch_protection`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and local_var_params.get('name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `repo_edit_branch_protection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "BranchProtection",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_git_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Edit a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_git_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param body:
        :type body: EditGitHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitHook
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_git_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_edit_git_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Edit a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_git_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param body:
        :type body: EditGitHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitHook, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_git_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_git_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_git_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_edit_git_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "GitHook",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Edit a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: index of the hook (required)
        :type id: int
        :param body:
        :type body: EditHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_edit_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Edit a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: index of the hook (required)
        :type id: int
        :param body:
        :type body: EditHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_edit_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Hook",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_pull_request(self, owner, repo, index, **kwargs):  # noqa: E501
        """Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_pull_request(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to edit (required)
        :type index: int
        :param body:
        :type body: EditPullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_pull_request_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_edit_pull_request_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_pull_request_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to edit (required)
        :type index: int
        :param body:
        :type body: EditPullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_pull_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_pull_request`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_pull_request`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_edit_pull_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "PullRequest",
            403: None,
            409: None,
            412: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_release(self, owner, repo, id, **kwargs):  # noqa: E501
        """Update a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to edit (required)
        :type id: int
        :param body:
        :type body: EditReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_release_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_edit_release_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Update a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to edit (required)
        :type id: int
        :param body:
        :type body: EditReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_release" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_release`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_release`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_edit_release`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Release",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_release_attachment(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Edit a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_attachment(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to edit (required)
        :type attachment_id: int
        :param body:
        :type body: EditAttachmentOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_release_attachment_with_http_info(owner, repo, id, attachment_id, **kwargs)  # noqa: E501

    def repo_edit_release_attachment_with_http_info(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Edit a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_attachment_with_http_info(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to edit (required)
        :type attachment_id: int
        :param body:
        :type body: EditAttachmentOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_release_attachment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_release_attachment`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_release_attachment`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_edit_release_attachment`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('attachment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `repo_edit_release_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['attachment_id'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Attachment",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_edit_wiki_page(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Edit a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_wiki_page(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_edit_wiki_page_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    def repo_edit_wiki_page_with_http_info(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Edit a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_wiki_page_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page_name',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_wiki_page" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_edit_wiki_page`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_edit_wiki_page`")  # noqa: E501
        # verify the required parameter 'page_name' is set
        if self.api_client.client_side_validation and local_var_params.get('page_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_name` when calling `repo_edit_wiki_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'page_name' in local_var_params:
            path_params['pageName'] = local_var_params['page_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "WikiPage",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get(self, owner, repo, **kwargs):  # noqa: E501
        """Get a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Repository",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_all_commits(self, owner, repo, **kwargs):  # noqa: E501
        """Get a list of all commits from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_all_commits(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA or branch to start listing commits from (usually 'master')
        :type sha: str
        :param path: filepath of a file/dir
        :type path: str
        :param stat: include diff stats for every commit (disable for speedup, default 'true')
        :type stat: bool
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results (ignored if used with 'path')
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Commit]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_all_commits_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_all_commits_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get a list of all commits from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_all_commits_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA or branch to start listing commits from (usually 'master')
        :type sha: str
        :param path: filepath of a file/dir
        :type path: str
        :param stat: include diff stats for every commit (disable for speedup, default 'true')
        :type stat: bool
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results (ignored if used with 'path')
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Commit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha',
            'path',
            'stat',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_all_commits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_all_commits`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_all_commits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('sha') is not None:  # noqa: E501
            query_params.append(('sha', local_var_params['sha']))  # noqa: E501
        if local_var_params.get('path') is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if local_var_params.get('stat') is not None:  # noqa: E501
            query_params.append(('stat', local_var_params['stat']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Commit]",
            404: None,
            409: "APIError",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_archive(self, owner, repo, archive, **kwargs):  # noqa: E501
        """Get an archive of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_archive(owner, repo, archive, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param archive: the git reference for download with attached archive format (e.g. master.zip) (required)
        :type archive: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_archive_with_http_info(owner, repo, archive, **kwargs)  # noqa: E501

    def repo_get_archive_with_http_info(self, owner, repo, archive, **kwargs):  # noqa: E501
        """Get an archive of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_archive_with_http_info(owner, repo, archive, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param archive: the git reference for download with attached archive format (e.g. master.zip) (required)
        :type archive: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'archive'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_archive" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_archive`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_archive`")  # noqa: E501
        # verify the required parameter 'archive' is set
        if self.api_client.client_side_validation and local_var_params.get('archive') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `archive` when calling `repo_get_archive`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'archive' in local_var_params:
            path_params['archive'] = local_var_params['archive']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/archive/{archive}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_assignees(self, owner, repo, **kwargs):  # noqa: E501
        """Return all users that have write access and can be assigned to issues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_assignees(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[User]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_assignees_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_assignees_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Return all users that have write access and can be assigned to issues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_assignees_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_assignees" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_assignees`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_assignees`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/assignees', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_branch(self, owner, repo, branch, **kwargs):  # noqa: E501
        """Retrieve a specific branch from a repository, including its effective branch protection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to get (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_branch_with_http_info(owner, repo, branch, **kwargs)  # noqa: E501

    def repo_get_branch_with_http_info(self, owner, repo, branch, **kwargs):  # noqa: E501
        """Retrieve a specific branch from a repository, including its effective branch protection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_with_http_info(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to get (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'branch'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_branch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_branch`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_branch`")  # noqa: E501
        # verify the required parameter 'branch' is set
        if self.api_client.client_side_validation and local_var_params.get('branch') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `branch` when calling `repo_get_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'branch' in local_var_params:
            path_params['branch'] = local_var_params['branch']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Branch",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches/{branch}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_branch_protection(self, owner, repo, name, **kwargs):  # noqa: E501
        """Get a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_protection(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_branch_protection_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    def repo_get_branch_protection_with_http_info(self, owner, repo, name, **kwargs):  # noqa: E501
        """Get a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_protection_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_branch_protection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_branch_protection`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_branch_protection`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and local_var_params.get('name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `repo_get_branch_protection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "BranchProtection",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_by_id(self, id, **kwargs):  # noqa: E501
        """Get a repository by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_by_id(id, async_req=True)
        >>> result = thread.get()

        :param id: id of the repo to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_by_id_with_http_info(id, **kwargs)  # noqa: E501

    def repo_get_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a repository by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: id of the repo to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Repository",
        }

        return self.api_client.call_api(
            '/repositories/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_combined_status_by_ref(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get a commit's combined status, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_combined_status_by_ref(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CombinedStatus
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_combined_status_by_ref_with_http_info(owner, repo, ref, **kwargs)  # noqa: E501

    def repo_get_combined_status_by_ref_with_http_info(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get a commit's combined status, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_combined_status_by_ref_with_http_info(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CombinedStatus, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'ref',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_combined_status_by_ref" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_combined_status_by_ref`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_combined_status_by_ref`")  # noqa: E501
        # verify the required parameter 'ref' is set
        if self.api_client.client_side_validation and local_var_params.get('ref') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `ref` when calling `repo_get_combined_status_by_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'ref' in local_var_params:
            path_params['ref'] = local_var_params['ref']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "CombinedStatus",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits/{ref}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_contents(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the dir, file, symlink or submodule in the repo (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContentsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_contents_with_http_info(owner, repo, filepath, **kwargs)  # noqa: E501

    def repo_get_contents_with_http_info(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_with_http_info(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the dir, file, symlink or submodule in the repo (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_contents" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_contents`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_contents`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_get_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "ContentsResponse",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_contents_list(self, owner, repo, **kwargs):  # noqa: E501
        """Gets the metadata of all the entries of the root dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_list(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ContentsResponse]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_contents_list_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_contents_list_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Gets the metadata of all the entries of the root dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_list_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ContentsResponse], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_contents_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_contents_list`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_contents_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[ContentsResponse]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_editor_config(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get the EditorConfig definitions of a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_editor_config(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_editor_config_with_http_info(owner, repo, filepath, **kwargs)  # noqa: E501

    def repo_get_editor_config_with_http_info(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get the EditorConfig definitions of a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_editor_config_with_http_info(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_editor_config" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_editor_config`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_editor_config`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_get_editor_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/editorconfig/{filepath}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_git_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a Git hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_git_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitHook
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_git_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_get_git_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a Git hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_git_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitHook, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_git_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_git_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_git_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_git_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "GitHook",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_get_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Hook",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_issue_templates(self, owner, repo, **kwargs):  # noqa: E501
        """Get available issue templates for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_issue_templates(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[IssueTemplate]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_issue_templates_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_issue_templates_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get available issue templates for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_issue_templates_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[IssueTemplate], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_issue_templates" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_issue_templates`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_issue_templates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[IssueTemplate]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/issue_templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_key(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a repository's key by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_key(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeployKey
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_key_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_get_key_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a repository's key by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_key_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeployKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_key`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_key`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "DeployKey",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_languages(self, owner, repo, **kwargs):  # noqa: E501
        """Get languages and number of bytes of code written  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_languages(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict(str, int)
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_languages_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_languages_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get languages and number of bytes of code written  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_languages_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict(str, int), status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_languages" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_languages`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_languages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "dict(str, int)",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/languages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_note(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a note corresponding to a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_note(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_note_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def repo_get_note_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a note corresponding to a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_note_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_note" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_note`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_note`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `repo_get_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Note",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/notes/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_pull_request(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_pull_request_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_get_pull_request_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_pull_request`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_pull_request`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_get_pull_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullRequest",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_pull_request_commits(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get commits for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_commits(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Commit]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_pull_request_commits_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_get_pull_request_commits_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get commits for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_commits_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Commit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request_commits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_pull_request_commits`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_pull_request_commits`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_get_pull_request_commits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Commit]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_pull_request_files(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get changed files for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_files(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param skip_to: skip to given file
        :type skip_to: str
        :param whitespace: whitespace behavior
        :type whitespace: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ChangedFile]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_pull_request_files_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_get_pull_request_files_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Get changed files for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_files_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param skip_to: skip to given file
        :type skip_to: str
        :param whitespace: whitespace behavior
        :type whitespace: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ChangedFile], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'skip_to',
            'whitespace',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request_files" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_pull_request_files`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_pull_request_files`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_get_pull_request_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []
        if local_var_params.get('skip_to') is not None:  # noqa: E501
            query_params.append(('skip-to', local_var_params['skip_to']))  # noqa: E501
        if local_var_params.get('whitespace') is not None:  # noqa: E501
            query_params.append(('whitespace', local_var_params['whitespace']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[ChangedFile]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_pull_review(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    def repo_get_pull_review_with_http_info(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_get_pull_review`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullReview",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_pull_review_comments(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_comments(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[PullReviewComment]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_pull_review_comments_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    def repo_get_pull_review_comments_with_http_info(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_comments_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[PullReviewComment], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_review_comments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_pull_review_comments`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_pull_review_comments`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_get_pull_review_comments`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_pull_review_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[PullReviewComment]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_push_mirror_by_remote_name(self, owner, repo, name, **kwargs):  # noqa: E501
        """Get push mirror of the repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_push_mirror_by_remote_name(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of push mirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PushMirror
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_push_mirror_by_remote_name_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    def repo_get_push_mirror_by_remote_name_with_http_info(self, owner, repo, name, **kwargs):  # noqa: E501
        """Get push mirror of the repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_push_mirror_by_remote_name_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of push mirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PushMirror, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_push_mirror_by_remote_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_push_mirror_by_remote_name`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_push_mirror_by_remote_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and local_var_params.get('name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `repo_get_push_mirror_by_remote_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PushMirror",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_raw_file(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get a file from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_raw_file_with_http_info(owner, repo, filepath, **kwargs)  # noqa: E501

    def repo_get_raw_file_with_http_info(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get a file from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_with_http_info(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_raw_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_raw_file`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_raw_file`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_get_raw_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/raw/{filepath}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_raw_file_or_lfs(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get a file or it's LFS object from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_or_lfs(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_raw_file_or_lfs_with_http_info(owner, repo, filepath, **kwargs)  # noqa: E501

    def repo_get_raw_file_or_lfs_with_http_info(self, owner, repo, filepath, **kwargs):  # noqa: E501
        """Get a file or it's LFS object from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_or_lfs_with_http_info(owner, repo, filepath, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_raw_file_or_lfs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_raw_file_or_lfs`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_raw_file_or_lfs`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_get_raw_file_or_lfs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/media/{filepath}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_release(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_release_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_get_release_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Get a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_release`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_release`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_release`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Release",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_release_attachment(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Get a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_attachment(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to get (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_release_attachment_with_http_info(owner, repo, id, attachment_id, **kwargs)  # noqa: E501

    def repo_get_release_attachment_with_http_info(self, owner, repo, id, attachment_id, **kwargs):  # noqa: E501
        """Get a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_attachment_with_http_info(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to get (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release_attachment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_release_attachment`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_release_attachment`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_get_release_attachment`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('attachment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `repo_get_release_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['attachment_id'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Attachment",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_release_by_tag(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Get a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_by_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to get (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_release_by_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    def repo_get_release_by_tag_with_http_info(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Get a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_by_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to get (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'tag'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release_by_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_release_by_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_release_by_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and local_var_params.get('tag') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag` when calling `repo_get_release_by_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'tag' in local_var_params:
            path_params['tag'] = local_var_params['tag']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Release",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/tags/{tag}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_repo_permissions(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Get repository permissions for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_repo_permissions(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepoCollaboratorPermission
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_repo_permissions_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    def repo_get_repo_permissions_with_http_info(self, owner, repo, collaborator, **kwargs):  # noqa: E501
        """Get repository permissions for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_repo_permissions_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepoCollaboratorPermission, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_repo_permissions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_repo_permissions`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_repo_permissions`")  # noqa: E501
        # verify the required parameter 'collaborator' is set
        if self.api_client.client_side_validation and local_var_params.get('collaborator') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `collaborator` when calling `repo_get_repo_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'collaborator' in local_var_params:
            path_params['collaborator'] = local_var_params['collaborator']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "RepoCollaboratorPermission",
            403: None,
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}/permission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_reviewers(self, owner, repo, **kwargs):  # noqa: E501
        """Return all users that can be requested to review in this repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_reviewers(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[User]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_reviewers_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_reviewers_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Return all users that can be requested to review in this repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_reviewers_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_reviewers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_reviewers`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_reviewers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/reviewers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_single_commit(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_single_commit(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Commit
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_single_commit_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def repo_get_single_commit_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_single_commit_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Commit, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_single_commit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_single_commit`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_single_commit`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `repo_get_single_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Commit",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/commits/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_tag(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Get the tag of a repository by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Tag
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    def repo_get_tag_with_http_info(self, owner, repo, tag, **kwargs):  # noqa: E501
        """Get the tag of a repository by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Tag, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'tag'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_tag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_tag`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if self.api_client.client_side_validation and local_var_params.get('tag') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag` when calling `repo_get_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'tag' in local_var_params:
            path_params['tag'] = local_var_params['tag']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "Tag",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags/{tag}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_wiki_page(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Get a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_wiki_page_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    def repo_get_wiki_page_with_http_info(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Get a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_page" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_wiki_page`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_wiki_page`")  # noqa: E501
        # verify the required parameter 'page_name' is set
        if self.api_client.client_side_validation and local_var_params.get('page_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_name` when calling `repo_get_wiki_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'page_name' in local_var_params:
            path_params['pageName'] = local_var_params['page_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "WikiPage",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_wiki_page_revisions(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Get revisions of a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_revisions(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiCommitList
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_wiki_page_revisions_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    def repo_get_wiki_page_revisions_with_http_info(self, owner, repo, page_name, **kwargs):  # noqa: E501
        """Get revisions of a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_revisions_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiCommitList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page_name',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_page_revisions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_wiki_page_revisions`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_wiki_page_revisions`")  # noqa: E501
        # verify the required parameter 'page_name' is set
        if self.api_client.client_side_validation and local_var_params.get('page_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_name` when calling `repo_get_wiki_page_revisions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'page_name' in local_var_params:
            path_params['pageName'] = local_var_params['page_name']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "WikiCommitList",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/revisions/{pageName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_get_wiki_pages(self, owner, repo, **kwargs):  # noqa: E501
        """Get all wiki pages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_pages(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[WikiPageMetaData]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_get_wiki_pages_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_get_wiki_pages_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get all wiki pages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_pages_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[WikiPageMetaData], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_pages" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_get_wiki_pages`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_get_wiki_pages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[WikiPageMetaData]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/pages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_all_git_refs(self, owner, repo, **kwargs):  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_all_git_refs(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Reference]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_all_git_refs_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_all_git_refs_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_all_git_refs_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Reference], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_all_git_refs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_all_git_refs`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_all_git_refs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Reference]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/refs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_branch_protection(self, owner, repo, **kwargs):  # noqa: E501
        """List branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branch_protection(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[BranchProtection]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_branch_protection_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_branch_protection_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branch_protection_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[BranchProtection], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_branch_protection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_branch_protection`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_branch_protection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[BranchProtection]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_branches(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branches(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Branch]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_branches_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_branches_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branches_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Branch], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_branches" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_branches`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_branches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Branch]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_collaborators(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_collaborators(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[User]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_collaborators_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_collaborators_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_collaborators_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_collaborators" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_collaborators`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_collaborators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_git_hooks(self, owner, repo, **kwargs):  # noqa: E501
        """List the Git hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_hooks(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[GitHook]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_git_hooks_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_git_hooks_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List the Git hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_hooks_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[GitHook], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_git_hooks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_git_hooks`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_git_hooks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[GitHook]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_git_refs(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_refs(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: part or full name of the ref (required)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Reference]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_git_refs_with_http_info(owner, repo, ref, **kwargs)  # noqa: E501

    def repo_list_git_refs_with_http_info(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_refs_with_http_info(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: part or full name of the ref (required)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Reference], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_git_refs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_git_refs`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_git_refs`")  # noqa: E501
        # verify the required parameter 'ref' is set
        if self.api_client.client_side_validation and local_var_params.get('ref') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `ref` when calling `repo_list_git_refs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'ref' in local_var_params:
            path_params['ref'] = local_var_params['ref']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Reference]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/refs/{ref}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_hooks(self, owner, repo, **kwargs):  # noqa: E501
        """List the hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_hooks(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Hook]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_hooks_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_hooks_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List the hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_hooks_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Hook], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_hooks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_hooks`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_hooks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Hook]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_keys(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_keys(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param key_id: the key_id to search for
        :type key_id: int
        :param fingerprint: fingerprint of the key
        :type fingerprint: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[DeployKey]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_keys_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_keys_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_keys_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param key_id: the key_id to search for
        :type key_id: int
        :param fingerprint: fingerprint of the key
        :type fingerprint: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[DeployKey], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'key_id',
            'fingerprint',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_keys" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_keys`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('key_id') is not None:  # noqa: E501
            query_params.append(('key_id', local_var_params['key_id']))  # noqa: E501
        if local_var_params.get('fingerprint') is not None:  # noqa: E501
            query_params.append(('fingerprint', local_var_params['fingerprint']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[DeployKey]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_pull_requests(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's pull requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_requests(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param state: State of pull request: open or closed (optional)
        :type state: str
        :param sort: Type of sort
        :type sort: str
        :param milestone: ID of the milestone
        :type milestone: int
        :param labels: Label IDs
        :type labels: list[int]
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[PullRequest]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_pull_requests_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_pull_requests_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's pull requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_requests_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param state: State of pull request: open or closed (optional)
        :type state: str
        :param sort: Type of sort
        :type sort: str
        :param milestone: ID of the milestone
        :type milestone: int
        :param labels: Label IDs
        :type labels: list[int]
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[PullRequest], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'state',
            'sort',
            'milestone',
            'labels',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_pull_requests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_pull_requests`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_pull_requests`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('state') is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if local_var_params.get('sort') is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if local_var_params.get('milestone') is not None:  # noqa: E501
            query_params.append(('milestone', local_var_params['milestone']))  # noqa: E501
        if local_var_params.get('labels') is not None:  # noqa: E501
            query_params.append(('labels', local_var_params['labels']))  # noqa: E501
            collection_formats['labels'] = 'multi'  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[PullRequest]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_pull_reviews(self, owner, repo, index, **kwargs):  # noqa: E501
        """List all reviews for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_reviews(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[PullReview]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_pull_reviews_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_list_pull_reviews_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """List all reviews for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_reviews_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[PullReview], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_pull_reviews" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_pull_reviews`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_pull_reviews`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_list_pull_reviews`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[PullReview]",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_push_mirrors(self, owner, repo, **kwargs):  # noqa: E501
        """Get all push mirrors of the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_push_mirrors(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[PushMirror]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_push_mirrors_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_push_mirrors_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get all push mirrors of the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_push_mirrors_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[PushMirror], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_push_mirrors" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_push_mirrors`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_push_mirrors`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[PushMirror]",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_release_attachments(self, owner, repo, id, **kwargs):  # noqa: E501
        """List release's attachments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_release_attachments(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Attachment]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_release_attachments_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_list_release_attachments_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """List release's attachments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_release_attachments_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Attachment], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_release_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_release_attachments`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_release_attachments`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_list_release_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Attachment]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_releases(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's releases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_releases(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param draft: filter (exclude / include) drafts, if you dont have repo write access none will show
        :type draft: bool
        :param pre_release: filter (exclude / include) pre-releases
        :type pre_release: bool
        :param per_page: page size of results, deprecated - use limit
        :type per_page: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Release]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_releases_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_releases_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's releases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_releases_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param draft: filter (exclude / include) drafts, if you dont have repo write access none will show
        :type draft: bool
        :param pre_release: filter (exclude / include) pre-releases
        :type pre_release: bool
        :param per_page: page size of results, deprecated - use limit
        :type per_page: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Release], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'draft',
            'pre_release',
            'per_page',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_releases" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_releases`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_releases`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('draft') is not None:  # noqa: E501
            query_params.append(('draft', local_var_params['draft']))  # noqa: E501
        if local_var_params.get('pre_release') is not None:  # noqa: E501
            query_params.append(('pre-release', local_var_params['pre_release']))  # noqa: E501
        if local_var_params.get('per_page') is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Release]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_stargazers(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's stargazers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_stargazers(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[User]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_stargazers_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_stargazers_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's stargazers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_stargazers_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_stargazers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_stargazers`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_stargazers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/stargazers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_statuses(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a commit's statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[CommitStatus]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_statuses_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    def repo_list_statuses_with_http_info(self, owner, repo, sha, **kwargs):  # noqa: E501
        """Get a commit's statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[CommitStatus], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'sha',
            'sort',
            'state',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_statuses" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_statuses`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_statuses`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `repo_list_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []
        if local_var_params.get('sort') is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if local_var_params.get('state') is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[CommitStatus]",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/statuses/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_statuses_by_ref(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get a commit's statuses, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_by_ref(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[CommitStatus]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_statuses_by_ref_with_http_info(owner, repo, ref, **kwargs)  # noqa: E501

    def repo_list_statuses_by_ref_with_http_info(self, owner, repo, ref, **kwargs):  # noqa: E501
        """Get a commit's statuses, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_by_ref_with_http_info(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[CommitStatus], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'ref',
            'sort',
            'state',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_statuses_by_ref" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_statuses_by_ref`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_statuses_by_ref`")  # noqa: E501
        # verify the required parameter 'ref' is set
        if self.api_client.client_side_validation and local_var_params.get('ref') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `ref` when calling `repo_list_statuses_by_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'ref' in local_var_params:
            path_params['ref'] = local_var_params['ref']  # noqa: E501

        query_params = []
        if local_var_params.get('sort') is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if local_var_params.get('state') is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[CommitStatus]",
            400: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits/{ref}/statuses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_subscribers(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's watchers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_subscribers(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[User]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_subscribers_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_subscribers_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's watchers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_subscribers_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_subscribers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_subscribers`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_subscribers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscribers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_tags(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_tags(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results, default maximum page size is 50
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Tag]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_tags_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_tags_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_tags_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results, default maximum page size is 50
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Tag], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_tags" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_tags`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Tag]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_teams(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's teams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_teams(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Team]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_teams_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_teams_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repository's teams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_teams_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Team], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_teams" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_teams`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_teams`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[Team]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_list_topics(self, owner, repo, **kwargs):  # noqa: E501
        """Get list of topics that a repository has  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_topics(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TopicName
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_list_topics_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_list_topics_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get list of topics that a repository has  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_topics_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TopicName, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_topics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_list_topics`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_list_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "TopicName",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_merge_pull_request(self, owner, repo, index, **kwargs):  # noqa: E501
        """Merge a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_merge_pull_request(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param body:
        :type body: MergePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_merge_pull_request_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_merge_pull_request_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Merge a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_merge_pull_request_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param body:
        :type body: MergePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_merge_pull_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_merge_pull_request`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_merge_pull_request`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_merge_pull_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_migrate(self, **kwargs):  # noqa: E501
        """Migrate a remote git repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_migrate(async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: MigrateRepoOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_migrate_with_http_info(**kwargs)  # noqa: E501

    def repo_migrate_with_http_info(self, **kwargs):  # noqa: E501
        """Migrate a remote git repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_migrate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: MigrateRepoOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_migrate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            201: "Repository",
            403: None,
            409: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/migrate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_mirror_sync(self, owner, repo, **kwargs):  # noqa: E501
        """Sync a mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_mirror_sync(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_mirror_sync_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_mirror_sync_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Sync a mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_mirror_sync_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_mirror_sync" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_mirror_sync`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_mirror_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/mirror-sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_pull_request_is_merged(self, owner, repo, index, **kwargs):  # noqa: E501
        """Check if a pull request has been merged  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_pull_request_is_merged(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_pull_request_is_merged_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_pull_request_is_merged_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Check if a pull request has been merged  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_pull_request_is_merged_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_pull_request_is_merged" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_pull_request_is_merged`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_pull_request_is_merged`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_pull_request_is_merged`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_push_mirror_sync(self, owner, repo, **kwargs):  # noqa: E501
        """Sync all push mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_push_mirror_sync(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_push_mirror_sync_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_push_mirror_sync_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Sync all push mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_push_mirror_sync_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_push_mirror_sync" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_push_mirror_sync`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_push_mirror_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors-sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_search(self, **kwargs):  # noqa: E501
        """Search for repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_search(async_req=True)
        >>> result = thread.get()

        :param q: keyword
        :type q: str
        :param topic: Limit search to repositories with keyword as topic
        :type topic: bool
        :param include_desc: include search of keyword within repository description
        :type include_desc: bool
        :param uid: search only for repos that the user with the given id owns or contributes to
        :type uid: int
        :param priority_owner_id: repo owner to prioritize in the results
        :type priority_owner_id: int
        :param team_id: search only for repos that belong to the given team id
        :type team_id: int
        :param starred_by: search only for repos that the user with the given id has starred
        :type starred_by: int
        :param private: include private repositories this user has access to (defaults to true)
        :type private: bool
        :param is_private: show only pubic, private or all repositories (defaults to all)
        :type is_private: bool
        :param template: include template repositories this user has access to (defaults to true)
        :type template: bool
        :param archived: show only archived, non-archived or all repositories (defaults to all)
        :type archived: bool
        :param mode: type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
        :type mode: str
        :param exclusive: if `uid` is given, search only for repos that the user owns
        :type exclusive: bool
        :param sort: sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
        :type sort: str
        :param order: sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
        :type order: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchResults
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_search_with_http_info(**kwargs)  # noqa: E501

    def repo_search_with_http_info(self, **kwargs):  # noqa: E501
        """Search for repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param q: keyword
        :type q: str
        :param topic: Limit search to repositories with keyword as topic
        :type topic: bool
        :param include_desc: include search of keyword within repository description
        :type include_desc: bool
        :param uid: search only for repos that the user with the given id owns or contributes to
        :type uid: int
        :param priority_owner_id: repo owner to prioritize in the results
        :type priority_owner_id: int
        :param team_id: search only for repos that belong to the given team id
        :type team_id: int
        :param starred_by: search only for repos that the user with the given id has starred
        :type starred_by: int
        :param private: include private repositories this user has access to (defaults to true)
        :type private: bool
        :param is_private: show only pubic, private or all repositories (defaults to all)
        :type is_private: bool
        :param template: include template repositories this user has access to (defaults to true)
        :type template: bool
        :param archived: show only archived, non-archived or all repositories (defaults to all)
        :type archived: bool
        :param mode: type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
        :type mode: str
        :param exclusive: if `uid` is given, search only for repos that the user owns
        :type exclusive: bool
        :param sort: sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
        :type sort: str
        :param order: sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
        :type order: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchResults, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'q',
            'topic',
            'include_desc',
            'uid',
            'priority_owner_id',
            'team_id',
            'starred_by',
            'private',
            'is_private',
            'template',
            'archived',
            'mode',
            'exclusive',
            'sort',
            'order',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('q') is not None:  # noqa: E501
            query_params.append(('q', local_var_params['q']))  # noqa: E501
        if local_var_params.get('topic') is not None:  # noqa: E501
            query_params.append(('topic', local_var_params['topic']))  # noqa: E501
        if local_var_params.get('include_desc') is not None:  # noqa: E501
            query_params.append(('includeDesc', local_var_params['include_desc']))  # noqa: E501
        if local_var_params.get('uid') is not None:  # noqa: E501
            query_params.append(('uid', local_var_params['uid']))  # noqa: E501
        if local_var_params.get('priority_owner_id') is not None:  # noqa: E501
            query_params.append(('priority_owner_id', local_var_params['priority_owner_id']))  # noqa: E501
        if local_var_params.get('team_id') is not None:  # noqa: E501
            query_params.append(('team_id', local_var_params['team_id']))  # noqa: E501
        if local_var_params.get('starred_by') is not None:  # noqa: E501
            query_params.append(('starredBy', local_var_params['starred_by']))  # noqa: E501
        if local_var_params.get('private') is not None:  # noqa: E501
            query_params.append(('private', local_var_params['private']))  # noqa: E501
        if local_var_params.get('is_private') is not None:  # noqa: E501
            query_params.append(('is_private', local_var_params['is_private']))  # noqa: E501
        if local_var_params.get('template') is not None:  # noqa: E501
            query_params.append(('template', local_var_params['template']))  # noqa: E501
        if local_var_params.get('archived') is not None:  # noqa: E501
            query_params.append(('archived', local_var_params['archived']))  # noqa: E501
        if local_var_params.get('mode') is not None:  # noqa: E501
            query_params.append(('mode', local_var_params['mode']))  # noqa: E501
        if local_var_params.get('exclusive') is not None:  # noqa: E501
            query_params.append(('exclusive', local_var_params['exclusive']))  # noqa: E501
        if local_var_params.get('sort') is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if local_var_params.get('order') is not None:  # noqa: E501
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "SearchResults",
            422: None,
        }

        return self.api_client.call_api(
            '/repos/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_signing_key(self, owner, repo, **kwargs):  # noqa: E501
        """Get signing-key.gpg for given repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_signing_key(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_signing_key_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_signing_key_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Get signing-key.gpg for given repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_signing_key_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_signing_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_signing_key`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_signing_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/signing-key.gpg', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_submit_pull_review(self, owner, repo, index, id, body, **kwargs):  # noqa: E501
        """Submit a pending review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_submit_pull_review(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: SubmitPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_submit_pull_review_with_http_info(owner, repo, index, id, body, **kwargs)  # noqa: E501

    def repo_submit_pull_review_with_http_info(self, owner, repo, index, id, body, **kwargs):  # noqa: E501
        """Submit a pending review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_submit_pull_review_with_http_info(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: SubmitPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_submit_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_submit_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_submit_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_submit_pull_review`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_submit_pull_review`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_submit_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullReview",
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_test_hook(self, owner, repo, id, **kwargs):  # noqa: E501
        """Test a push webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_test_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to test (required)
        :type id: int
        :param ref: The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_test_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    def repo_test_hook_with_http_info(self, owner, repo, id, **kwargs):  # noqa: E501
        """Test a push webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_test_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to test (required)
        :type id: int
        :param ref: The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'id',
            'ref'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_test_hook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_test_hook`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_test_hook`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_test_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if local_var_params.get('ref') is not None:  # noqa: E501
            query_params.append(('ref', local_var_params['ref']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}/tests', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_tracked_times(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's tracked times  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_tracked_times(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: optional filter by user (available for issue managers)
        :type user: str
        :param since: Only show times updated after the given time. This is a timestamp in RFC 3339 format
        :type since: datetime
        :param before: Only show times updated before the given time. This is a timestamp in RFC 3339 format
        :type before: datetime
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TrackedTime]
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_tracked_times_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_tracked_times_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """List a repo's tracked times  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_tracked_times_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: optional filter by user (available for issue managers)
        :type user: str
        :param since: Only show times updated after the given time. This is a timestamp in RFC 3339 format
        :type since: datetime
        :param before: Only show times updated before the given time. This is a timestamp in RFC 3339 format
        :type before: datetime
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TrackedTime], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'user',
            'since',
            'before',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_tracked_times" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_tracked_times`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_tracked_times`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []
        if local_var_params.get('user') is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
        if local_var_params.get('since') is not None:  # noqa: E501
            query_params.append(('since', local_var_params['since']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[TrackedTime]",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/times', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_transfer(self, owner, repo, body, **kwargs):  # noqa: E501
        """Transfer a repo ownership  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_transfer(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param body: Transfer Options (required)
        :type body: TransferRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_transfer_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    def repo_transfer_with_http_info(self, owner, repo, body, **kwargs):  # noqa: E501
        """Transfer a repo ownership  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_transfer_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param body: Transfer Options (required)
        :type body: TransferRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_transfer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_transfer`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_transfer`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            202: "Repository",
            403: None,
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_un_dismiss_pull_review(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Cancel to dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_un_dismiss_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_un_dismiss_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    def repo_un_dismiss_pull_review_with_http_info(self, owner, repo, index, id, **kwargs):  # noqa: E501
        """Cancel to dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_un_dismiss_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_un_dismiss_pull_review" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_un_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_un_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_un_dismiss_pull_review`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `repo_un_dismiss_pull_review`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "PullReview",
            403: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_update_file(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Update a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to update (required)
        :type filepath: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_update_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    def repo_update_file_with_http_info(self, owner, repo, filepath, body, **kwargs):  # noqa: E501
        """Update a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to update (required)
        :type filepath: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_update_file`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_update_file`")  # noqa: E501
        # verify the required parameter 'filepath' is set
        if self.api_client.client_side_validation and local_var_params.get('filepath') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filepath` when calling `repo_update_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `repo_update_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'filepath' in local_var_params:
            path_params['filepath'] = local_var_params['filepath']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PUT', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "FileResponse",
            403: None,
            404: None,
            422: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_update_pull_request(self, owner, repo, index, **kwargs):  # noqa: E501
        """Merge PR's baseBranch into headBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_pull_request(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param style: how to update pull request
        :type style: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_update_pull_request_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    def repo_update_pull_request_with_http_info(self, owner, repo, index, **kwargs):  # noqa: E501
        """Merge PR's baseBranch into headBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_pull_request_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param style: how to update pull request
        :type style: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'index',
            'style'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_pull_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_update_pull_request`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_update_pull_request`")  # noqa: E501
        # verify the required parameter 'index' is set
        if self.api_client.client_side_validation and local_var_params.get('index') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `index` when calling `repo_update_pull_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []
        if local_var_params.get('style') is not None:  # noqa: E501
            query_params.append(('style', local_var_params['style']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def repo_update_topics(self, owner, repo, **kwargs):  # noqa: E501
        """Replace list of topics for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_topics(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: RepoTopicOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.repo_update_topics_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def repo_update_topics_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Replace list of topics for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_topics_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: RepoTopicOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_topics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `repo_update_topics`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `repo_update_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain'],
                'PUT', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def topic_search(self, q, **kwargs):  # noqa: E501
        """search topics via keyword  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.topic_search(q, async_req=True)
        >>> result = thread.get()

        :param q: keywords to search (required)
        :type q: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TopicResponse]
        """
        kwargs['_return_http_data_only'] = True
        return self.topic_search_with_http_info(q, **kwargs)  # noqa: E501

    def topic_search_with_http_info(self, q, **kwargs):  # noqa: E501
        """search topics via keyword  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.topic_search_with_http_info(q, async_req=True)
        >>> result = thread.get()

        :param q: keywords to search (required)
        :type q: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TopicResponse], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'q',
            'page',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method topic_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'q' is set
        if self.api_client.client_side_validation and local_var_params.get('q') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `q` when calling `topic_search`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('q') is not None:  # noqa: E501
            query_params.append(('q', local_var_params['q']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[TopicResponse]",
            403: None,
        }

        return self.api_client.call_api(
            '/topics/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_current_check_subscription(self, owner, repo, **kwargs):  # noqa: E501
        """Check if the current user is watching a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_check_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WatchInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.user_current_check_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def user_current_check_subscription_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Check if the current user is watching a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_check_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WatchInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_check_subscription" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `user_current_check_subscription`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `user_current_check_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "WatchInfo",
            404: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_current_delete_subscription(self, owner, repo, **kwargs):  # noqa: E501
        """Unwatch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_delete_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.user_current_delete_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def user_current_delete_subscription_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Unwatch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_delete_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_delete_subscription" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `user_current_delete_subscription`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `user_current_delete_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_current_put_subscription(self, owner, repo, **kwargs):  # noqa: E501
        """Watch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_put_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WatchInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.user_current_put_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    def user_current_put_subscription_with_http_info(self, owner, repo, **kwargs):  # noqa: E501
        """Watch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_put_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WatchInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_put_subscription" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `user_current_put_subscription`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `user_current_put_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "WatchInfo",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_tracked_times(self, owner, repo, user, **kwargs):  # noqa: E501
        """List a user's tracked times in a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_tracked_times(owner, repo, user, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: username of user (required)
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TrackedTime]
        """
        kwargs['_return_http_data_only'] = True
        return self.user_tracked_times_with_http_info(owner, repo, user, **kwargs)  # noqa: E501

    def user_tracked_times_with_http_info(self, owner, repo, user, **kwargs):  # noqa: E501
        """List a user's tracked times in a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_tracked_times_with_http_info(owner, repo, user, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: username of user (required)
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TrackedTime], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'owner',
            'repo',
            'user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_tracked_times" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and local_var_params.get('owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner` when calling `user_tracked_times`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if self.api_client.client_side_validation and local_var_params.get('repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repo` when calling `user_tracked_times`")  # noqa: E501
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and local_var_params.get('user') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user` when calling `user_tracked_times`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in local_var_params:
            path_params['owner'] = local_var_params['owner']  # noqa: E501
        if 'repo' in local_var_params:
            path_params['repo'] = local_var_params['repo']  # noqa: E501
        if 'user' in local_var_params:
            path_params['user'] = local_var_params['user']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AccessToken', 'AuthorizationHeaderToken', 'BasicAuth', 'SudoHeader', 'SudoParam', 'TOTPHeader', 'Token']  # noqa: E501

        response_types_map = {
            200: "list[TrackedTime]",
            400: None,
            403: None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/times/{user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
